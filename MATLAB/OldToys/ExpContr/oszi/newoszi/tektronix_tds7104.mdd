<?xml version="1.0" encoding="utf-8"?>
<MATLABInstrumentDriver>
   <FileVersion>1.0</FileVersion>
   <DriverName>D:\sandbox\matlab\toolbox\instrument\instrument\drivers\tektronix_tds2024.mdd</DriverName>
   <DriverType>MATLAB interface object</DriverType>
   <InstrumentType>Oscilloscope</InstrumentType>
   <InstrumentManufacturer>Tektronix</InstrumentManufacturer>
   <InstrumentModel>TDS7104</InstrumentModel>
   <InstrumentVersion>1.0</InstrumentVersion>
   <Identify>*IDN?</Identify>
   <Reset>*RST; HEADER OFF; VERBOSE ON</Reset>
   <Selftest>*TST?</Selftest>
   <Error>*ESR?;ALLEv?</Error>
   <CreateInitCode>
      <Code>function init(obj)
% This method is called after the object is created.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

% Extract the interface object.
interface = get(obj, 'Interface');

fclose(interface);

% Configure the buffer size to allow for waveform transfer.
set(interface, 'InputBufferSize', 1000000);
set(interface, 'OutputBufferSize', 101000);
</Code>
   </CreateInitCode>
   <ConnectInitCode>
      <Type>MCode</Type>
      <Code>function init(obj)
% This method is called after the object is connected.
% OBJ is the device object.
% End of function definition - DO NOT EDIT

%get the interface
interface = get(obj, 'interface');

%If HEADER is not OFF or VERBOSE is not ON then responses retrieved from
% the device will not match what is expected, and the driver will not
% function properly.
fprintf(interface, 'HEADER OFF');
fprintf(interface, 'VERBOSE ON');

%Clear the Standard Event Status Register (SESR) to remove possible Power
% on event, which would otherwise be returned by getError.
query(interface, '*ESR?');</Code>
   </ConnectInitCode>
   <CleanupCode>
      <Type>InstrumentCommand</Type>
   </CleanupCode>
   <GroupInfo>
      <Group>
         <Name>parent</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="parent1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>ResponseHeaderState</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>HEADer?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Queries the Response Header Enable State that causes the oscilloscope to either include or omit headers on query responses.

NOTE: Although the property is not truly read only for the instrument, the value must be 'off' for the driver to operate correctly.  As a result, it is set as read-only for the driver.</Description>
            </Property>
            <Property>
               <Name>VerboseEnabled</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>VERBose</ConfigureCommand>
                     <QueryCommand>VERBose?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="off" Value="0"/>
                     <Enum Name="on" Value="1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Queries the Verbose state that controls the length of keywords on query responses.

Although this property is configurable on the instrument, the driver requires that it always be on so that we receive predictable responses from the instrument.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>autoset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <Line Command="AUTOSet EXECUTE" Output="false"/>
                  </Commands>
               </Code>
               <Description>AUTOSET Automatic parameter adjustment.

INVOKE(OBJ, 'autoset') causes the oscilloscope to adjust its vertical, horizontal, and trigger controls to display a more stable waveform.</Description>
            </Method>
            <Method>
               <Name>factoryreset</Name>
               <Location>parent</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <Line Command="FACtory" Output="false"/>
                     <Line Command="HEADER OFF" Output="false"/>
                  </Commands>
               </Code>
               <Description>FACTORYRESET  Resets the oscilloscope to its factory default settings.

INVOKE(OBJ, 'factoryreset')  resets the oscilloscope to its factory settings.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>acquisition</Name>
         <Description>The aquisition group define properties and function related to how the waveform is acquired and the timebase.</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Acquisition1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>AcquisitionCount</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>ACQuire:NUMACq?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Indicate the number of acquisitions that have taken place since starting oscilloscope acquisition.</Description>
            </Property>
            <Property>
               <Name>Control</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>ACQuire:STOPAfter</ConfigureCommand>
                     <QueryCommand>ACQuire:STOPAfter?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="run-stop" Value="RUNSTOP"/>
                     <Enum Name="single" Value="SEQUENCE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>run-stop</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Tells the oscilloscope when to stop taking acquisitions for edge trigger type.  If the property value is 'run-stop' then acquisition is controlled by the run/stop button on the oscilloscope.  If the value 'single' then a single acquisition is performed (note that 'single acquisition may include multiple triggers and wavforms depending on other property settings such as NumberOfAverages.</Description>
            </Property>
            <Property>
               <Name>Delay</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>HORizontal:MAIn:POSition</ConfigureCommand>
                     <QueryCommand>HORizontal:MAIn:POSition?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="99.999" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the main time base horizontal position.</Description>
            </Property>
            <Property>
               <Name>FastAcquisition</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>FASTAcq:STATE</ConfigureCommand>
                     <QueryCommand>FASTAcq:STATE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enables or disables Fast Acquisition.</Description>
            </Property>
            <Property>
               <Name>Mode</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>ACQuire:MODe</ConfigureCommand>
                     <QueryCommand>ACQuire:MODe?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="sample" Value="SAMPLE"/>
                     <Enum Name="peakDetect" Value="PEAKDETECT"/>
                     <Enum Name="average" Value="AVERAGE"/>
                     <Enum Name="hires" Value="HIRES"/>
                     <Enum Name="envelope" Value="ENVELOPE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Sample</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or query the oscilloscope acquisition mode.</Description>
            </Property>
            <Property>
               <Name>NumberOfAverages</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>ACQuire:NUMAVg</ConfigureCommand>
                     <QueryCommand>ACQuire:NUMAVg?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="10000.0" Min="2.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>4.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the number of oscilloscope waveform acquisitions that make up an averaged waveform.</Description>
            </Property>
            <Property>
               <Name>State</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>ACQ:STATE</ConfigureCommand>
                     <QueryCommand>ACQ:STATE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="stop" Value="0"/>
                     <Enum Name="run" Value="1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>stop</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Starts or stops oscilloscope acquisitions.</Description>
            </Property>
            <Property>
               <Name>Timebase</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>HORizontal:MAIn:SCALe</ConfigureCommand>
                     <QueryCommand>HORizontal:MAIn:SCALe?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="40.0" Min="2.0E-10"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the time per divison for the main time base.</Description>
            </Property>
            <Property>
               <Name>WindowDelay</Name>
               <Location>acquisition</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>HORizontal:DELay:POSition</ConfigureCommand>
                     <QueryCommand>HORizontal:DELay:POSition?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="99.999" Min="0.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries The window time base horizontal position.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo/>
      </Group>
      <Group>
         <Name>channel</Name>
         <Description/>
         <Command/>
         <Size>4</Size>
         <Mappings>
            <ChannelMap Command="CH4" Index="4"/>
            <ChannelMap Command="CH3" Index="3"/>
            <ChannelMap Command="CH2" Index="2"/>
            <ChannelMap Command="CH1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>BandwidthLimit</Name>
               <Location>channel</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the devide object
device = get(obj,'Parent');

%get the interface
interface = get(device, 'Interface');

%get the &lt;ID&gt;, e.g.: CH1, CH2...
id = get(obj,'HwName');

%ask for the property value from the device
%send the commands as a string (%s)
%return the value as a float (%f)
bandwidthLimit = query(interface,[ id, ':bandwidth?'],'%s','%f');

%value is returned in Hertz, convert to MegaHertz
propertyValue = bandwidthLimit/1000000;
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the devide object
device = get(obj,'Parent');

%get the interface
interface = get(device, 'Interface');

%get the &lt;ID&gt;, e.g.: CH1, CH2...
id = get(obj,'HwName');

%find out if propertyValue was passed as a char ('full'), then we can send
%the command directly to the device
if ischar(propertyValue)
	fprintf(interface, [id, ':bandwidth FULL']);
	
%otherwise, we have to convert from MHz to Hz
else
	bandwidthLimit = propertyValue*1000000;
	fprintf(interface, [id, ':bandwidth ',num2str(bandwidthLimit)]);
	
end%if ischar(propertyValue)</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>20.0</Value>
                     <Value>250.0</Value>
                     <Value>1000.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="full" Value="1000000000"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>20.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the bandwidth setting of the specified oscilloscope channel.

</Description>
            </Property>
            <Property>
               <Name>Coupling</Name>
               <Location>channel</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>&lt;ID&gt;:COUP</ConfigureCommand>
                     <QueryCommand>&lt;ID&gt;:COUP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ac" Value="AC"/>
                     <Enum Name="dc" Value="DC"/>
                     <Enum Name="ground" Value="GND"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ac</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the vertical gain of the specified oscilloscope channel.</Description>
            </Property>
            <Property>
               <Name>Impedance</Name>
               <Location>channel</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>&lt;ID&gt;:TERmination</ConfigureCommand>
                     <QueryCommand>&lt;ID&gt;:TERmination?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="fifty" Value="50.0000"/>
                     <Enum Name="onemillion" Value="1.0000E+6"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>fifty</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the connected/ddisconnected status of the 50 ohm resistor.</Description>
            </Property>
            <Property>
               <Name>Offset</Name>
               <Location>channel</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>&lt;ID&gt;:OFFSET</ConfigureCommand>
                     <QueryCommand>&lt;ID&gt;:OFFSET?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the offset of the select channel in volts.</Description>
            </Property>
            <Property>
               <Name>Position</Name>
               <Location>channel</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>&lt;ID&gt;:POSition</ConfigureCommand>
                     <QueryCommand>&lt;ID&gt;:POSition?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8.0" Min="-8.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the vertical position of the specified oscilloscope channel in divisions above the center graticule.
</Description>
            </Property>
            <Property>
               <Name>Scale</Name>
               <Location>channel</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>&lt;ID&gt;:SCAle</ConfigureCommand>
                     <QueryCommand>&lt;ID&gt;:SCAle?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <DependentProperty>Impedance</DependentProperty>
                  <DependentPropertyValue>1.0000e+6</DependentPropertyValue>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="10.0" Min="0.0010"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>Double</Type>
                  <DependentProperty>Impedance</DependentProperty>
                  <DependentPropertyValue>50.0000</DependentPropertyValue>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="1.0" Min="0.0010"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0020</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the vertical gain of the specified oscilloscope channel.</Description>
            </Property>
            <Property>
               <Name>State</Name>
               <Location>channel</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Select:&lt;ID&gt;</ConfigureCommand>
                     <QueryCommand>Select:&lt;ID&gt;?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="off" Value="0"/>
                     <Enum Name="on" Value="1"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>off</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Enable or disable the display of the waveform on the scope.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo/>
      </Group>
      <Group>
         <Name>cursor</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Cursor1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>CursorType</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CURSor:FUNCtion</ConfigureCommand>
                     <QueryCommand>CURSor:FUNCtion?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="horizontalBars" Value="HBARS"/>
                     <Enum Name="verticalBars" Value="VBARS"/>
                     <Enum Name="paired" Value="PAIRED"/>
                     <Enum Name="split" Value="SPLIT"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>horizontalBars</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Selects the cursor type.</Description>
            </Property>
            <Property>
               <Name>Enable</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CURSor:STATE</ConfigureCommand>
                     <QueryCommand>CURSor:STATE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>HorizontalBarDelta</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>CURSor:HBArs:DELTa?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returs the difference (in verticalunits) between the two horizontal bar cursors in the oscilloscope display.</Description>
            </Property>
            <Property>
               <Name>HorizontalBarPosition1</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CURSor:HBArs:POSITION1</ConfigureCommand>
                     <QueryCommand>CURSor:HBArs:POSITION1?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Specifies the first horizontal bar cursor position.</Description>
            </Property>
            <Property>
               <Name>HorizontalBarPosition2</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CURSor:HBArs:POSITION2</ConfigureCommand>
                     <QueryCommand>CURSor:HBArs:POSITION2?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Specifies the second horizontal bar cursor position.</Description>
            </Property>
            <Property>
               <Name>HorizontalBarUnits</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>CURSor:HBARS:UNIts?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="volts" Value="VOL"/>
                     <Enum Name="divisions" Value="DIV"/>
                     <Enum Name="decibels" Value="DECIBELS"/>
                     <Enum Name="unknown" Value="UNKNOWN"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>volts</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the vertical scale units for the selected cursor source waveform.</Description>
            </Property>
            <Property>
               <Name>Source</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CURSor:SOUrce</ConfigureCommand>
                     <QueryCommand>CURSor:SOUrce?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="channel1" Value="CH1"/>
                     <Enum Name="channel2" Value="CH2"/>
                     <Enum Name="reference1" Value="REF1"/>
                     <Enum Name="reference2" Value="REF2"/>
                     <Enum Name="math1" Value="MATH1"/>
                     <Enum Name="channel3" Value="CH3"/>
                     <Enum Name="channel4" Value="CH4"/>
                     <Enum Name="reference3" Value="REF3"/>
                     <Enum Name="reference4" Value="REF4"/>
                     <Enum Name="math2" Value="MATH2"/>
                     <Enum Name="math3" Value="MATH3"/>
                     <Enum Name="math4" Value="MATH4"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Channel1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the waveform that is the source of the vertical and horizontal scale factors used in determining cursor values.</Description>
            </Property>
            <Property>
               <Name>VerticalBarDelta</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>CURSor:VBArs:DELTa?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the time or frequency difference between the two vertical bar cursors.</Description>
            </Property>
            <Property>
               <Name>VerticalBarPosition1</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the device
device = get(obj,'Parent');

%get the interface
interface = get(device,'Interface');

%Tell the instrument you want it to tell you the value
fprintf(interface, 'CURSor:VBArs:POSITION1?');

%retrieve the value from the instrument, and convert it to a double
propertyValue = fscanf(interface,'%f');
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the device
device = get(obj,'Parent');

%get the interface
interface = get(device,'Interface');

mode = 'MAIn';

%request the TimeBase (or WindowTimeBase) from the instrument
fprintf(interface,['HORizontal:',mode,':SCALe?']);
timebase = fscanf(interface,'%f');

%request the Delay (or WindowDelay) from the instrument
fprintf(interface,['HORizontal:',mode,':POSition?']);
delay = fscanf(interface,'%f');

%reticule has 10 division, timebase is seconds/division
% range is the seconds across the entire display
range = 10*timebase;

%horizontal cursor positions can range from one side of the display to the
% other, and are measured in seconds
minimum = -1*range/2-delay;
maximum = range/2-delay;

if propertyValue &gt; maximum || propertyValue &lt; minimum
	
	error(['Invalid value for VerticalBarPosition1. ',...
		'Valid values for current Scale and Position settings: ',...
		'a value between ',num2str(minimum),' and ',num2str(maximum)]);
	
end%if propertyValue &gt; maximum || propertyValue &lt; minimum

%set the property to the specified value
fprintf(interface, ['CURSor:VBArs:POSITION1 ', num2str(propertyValue)]);







</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Specifies the first vertical bar cursor position.</Description>
            </Property>
            <Property>
               <Name>VerticalBarPosition2</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the device
device = get(obj,'Parent');

%get the interface
interface = get(device,'Interface');

%Tell the instrument you want it to tell you the value
fprintf(interface, 'CURSor:VBArs:POSITION2?');

%retrieve the value from the instrument, and convert it to a double
propertyValue = fscanf(interface,'%f');
</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the device
device = get(obj,'Parent');

%get the interface
interface = get(device,'Interface');

mode = 'MAIn';

%request the TimeBase (or WindowTimeBase) from the instrument
fprintf(interface,['HORizontal:',mode,':SCALe?']);
timebase = fscanf(interface,'%f');

%request the Delay (or WindowDelay) from the instrument
fprintf(interface,['HORizontal:',mode,':POSition?']);
delay = fscanf(interface,'%f');

%reticule has 10 division, timebase is seconds/division
% range is the seconds across the entire display
range = 10*timebase;

%horizontal cursor positions can range from one side of the display to the
% other, and are measured in seconds
minimum = -1*range/2-delay;
maximum = range/2-delay;

if propertyValue &gt; maximum || propertyValue &lt; minimum
	
	error(['Invalid value for VerticalBarPosition1. ',...
		'Valid values for current Scale and Position settings: ',...
		'a value between ',num2str(minimum),' and ',num2str(maximum)]);
	
end%if propertyValue &gt; maximum || propertyValue &lt; minimum

%set the property to the specified value
fprintf(interface, ['CURSor:VBArs:POSITION2 ', num2str(propertyValue)]);







</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Specifies the second vertical bar cursor position.</Description>
            </Property>
            <Property>
               <Name>VerticalBarUnits</Name>
               <Location>cursor</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>CURSor:VBArs:UNIts</ConfigureCommand>
                     <QueryCommand>CURSor:VBArs:UNIts?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="seconds" Value="SECO"/>
                     <Enum Name="hertz" Value="HER"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>seconds</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the units for the vertical bar cursors.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo/>
      </Group>
      <Group>
         <Name>display</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Display1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>Format</Name>
               <Location>display</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>DISPlay:FORMat</ConfigureCommand>
                     <QueryCommand>DISPlay:FORMat?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="xy" Value="XY"/>
                     <Enum Name="yt" Value="YT"/>
                     <Enum Name="xyz" Value="XYZ"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>YT</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the oscilloscope display format.</Description>
            </Property>
            <Property>
               <Name>Persistence</Name>
               <Location>display</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get Device Object
deviceObj = get(obj,'Parent');

%get Interface
interface = get(deviceObj,'Interface');

%get the persistence state
fprintf(interface,'DISPlay:PERSistence?');
style = fscanf(interface);

if strncmpi( style,'OFF',min(3,length('style')) )
	propertyValue = 0;
elseif strncmpi( style,'INFPersist',min(10,length(style)) )
	propertyValue = 99;
elseif strncmpi( style,'VARPersist',min(10,length(style)) )
	
	%get the actual persistence value
	fprintf(interface, 'DISPlay:VARPersist?');
	propertyValue = fscanf(interface,'%f');
	
else
	error(['Unexpected value returned for Persistence. Expected:'...
		' ''OFF'',''INFPersist'', or ''VARPersist''. Received: '...
		style]);
end</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get Device Object
deviceObj = get(obj,'Parent');

%get Interface
interface = get(deviceObj,'Interface');

%0 = off
if propertyValue == 0
	fprintf(interface,'DISPlay:PERSistence OFF')
%%99 = inf
elseif propertyValue == 99
	fprintf(interface,'DISPlay:PERSistence INFPersist');
%%anything else = variable
else
	%set the mode
	fprintf(interface,'DISPlay:PERSistence VARPersist');
	%set the value
	fprintf(interface,['DISPlay:VARPersist ',num2str(propertyValue)]);
end
	
	

</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="10.0" Min="0.05"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Value>0.0</Value>
                     <Value>99.0</Value>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the length of time that data points are displayed.</Description>
            </Property>
            <Property>
               <Name>Style</Name>
               <Location>display</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>DISPlay:STYle</ConfigureCommand>
                     <QueryCommand>DISPlay:STYle?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="dots" Value="DOTs"/>
                     <Enum Name="vectors" Value="VECtors"/>
                     <Enum Name="intensified" Value="INTENSIFIED"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Dots</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Selects how to display the waveform data.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo/>
      </Group>
      <Group>
         <Name>math</Name>
         <Description/>
         <Command/>
         <Size>4</Size>
         <Mappings>
            <ChannelMap Command="4" Index="4"/>
            <ChannelMap Command="3" Index="3"/>
            <ChannelMap Command="2" Index="2"/>
            <ChannelMap Command="1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>Definition</Name>
               <Location>math</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the Parent Object
device = get(obj,'Parent');

%get the interface
interface = get(device,'Interface');

%get the value
fprintf(interface, [get(obj,'HwName'),':DEFIne?']);</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the Parent Object
device = get(obj,'Parent');

%get the interface
interface = get(device,'Interface');

%set the value
%The only reason MCode is used is so that the string can be wrapped in 
%	double quotes before sent, so the user doesn't have to do it.
fprintf(interface, [get(obj,'HwName'),':DEFIne "',propertyValue,'"']);</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ch1 + ch2" Value="&#34;CH1 + CH2&#34;"/>
                     <Enum Name="ch1 - ch2" Value="&#34;CH1 - CH2&#34;"/>
                     <Enum Name="ch2 - ch1" Value="&#34;CH2 - CH1&#34;"/>
                     <Enum Name="ch3 + ch4" Value="&#34;CH3 + CH4&#34;"/>
                     <Enum Name="ch3 - ch4" Value="&#34;CH3 - CH4&#34;"/>
                     <Enum Name="ch4 - ch3" Value="&#34;CH4 - CH3&#34;"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>ch1 + ch2</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Define a mathwaveform</Description>
            </Property>
            <Property>
               <Name>Label</Name>
               <Location>math</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the Parent object
parent = get(obj,'Parent');

%get the interface
interface = get(parent,'Interface');

%ask for the value
fprintf(interface, ['MATH',obj.HwName,':LABEL:NAMe?']);

%return the value
propertyValue = fscanf(interface);</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get the Parent object
parent = get(obj,'Parent');

%get the interface
interface = get(parent,'Interface');

%send the value
fprintf(interface, ['MATH',obj.HwName,':LABEL:NAMe "',propertyValue,'"']);</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue/>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>LabelXPosition</Name>
               <Location>math</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>MATH&lt;ID&gt;:LABEL:XPOS</ConfigureCommand>
                     <QueryCommand>MATH&lt;ID&gt;:LABEL:XPOS?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>LabelYPosition</Name>
               <Location>math</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>MATH&lt;ID&gt;:LABEL:YPOS</ConfigureCommand>
                     <QueryCommand>MATH&lt;ID&gt;:LABEL:YPOS?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Position</Name>
               <Location>math</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>MATH&lt;ID&gt;:POSition</ConfigureCommand>
                     <QueryCommand>MATH&lt;ID&gt;:POSition?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>Scale</Name>
               <Location>math</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>MATH&lt;ID&gt;:SCAle</ConfigureCommand>
                     <QueryCommand>MATH&lt;ID&gt;:SCAle?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>State</Name>
               <Location>math</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>SELECT:MATH&lt;ID&gt;</ConfigureCommand>
                     <QueryCommand>SELECT:MATH&lt;ID&gt;?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="on" Value="1"/>
                     <Enum Name="off" Value="0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>on</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo/>
      </Group>
      <Group>
         <Name>measurement</Name>
         <Description/>
         <Command/>
         <Size>9</Size>
         <Mappings>
            <ChannelMap Command="IMMED" Index="9"/>
            <ChannelMap Command="MEAS8" Index="8"/>
            <ChannelMap Command="MEAS7" Index="7"/>
            <ChannelMap Command="MEAS6" Index="6"/>
            <ChannelMap Command="MEAS5" Index="5"/>
            <ChannelMap Command="MEAS4" Index="4"/>
            <ChannelMap Command="MEAS3" Index="3"/>
            <ChannelMap Command="MEAS2" Index="2"/>
            <ChannelMap Command="MEAS1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>MeasurementType</Name>
               <Location>measurement</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>MEASUrement:&lt;ID&gt;:TYPe</ConfigureCommand>
                     <QueryCommand>MEASUrement:&lt;ID&gt;:TYPe?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="frequency" Value="FREQ"/>
                     <Enum Name="mean" Value="MEAN"/>
                     <Enum Name="period" Value="PERI"/>
                     <Enum Name="peak2peak" Value="PK2PK"/>
                     <Enum Name="crms" Value="CRM"/>
                     <Enum Name="minimum" Value="MINI"/>
                     <Enum Name="maximum" Value="MAX"/>
                     <Enum Name="positivewidth" Value="PWIDTH"/>
                     <Enum Name="negativewidth" Value="NWIDTH"/>
                     <Enum Name="amplitude" Value="AMP"/>
                     <Enum Name="area" Value="ARE"/>
                     <Enum Name="carea" Value="CAR"/>
                     <Enum Name="burst" Value="BUR"/>
                     <Enum Name="cmean" Value="CME"/>
                     <Enum Name="delay" Value="DEL"/>
                     <Enum Name="fall" Value="FALL"/>
                     <Enum Name="high" Value="HIGH"/>
                     <Enum Name="low" Value="LOW"/>
                     <Enum Name="negativeduty" Value="NDUTY"/>
                     <Enum Name="positiveduty" Value="PDUTY"/>
                     <Enum Name="negativeovershoot" Value="NOVERSHOOT"/>
                     <Enum Name="positiveovershoot" Value="POVERSHOOT"/>
                     <Enum Name="phase" Value="PHA"/>
                     <Enum Name="rise" Value="RIS"/>
                     <Enum Name="rms" Value="RMS"/>
                     <Enum Name="undefined" Value="UNDEFINED"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Frequency</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or query the measurement type.  By default this driver supports the standard measurement types of the oscilloscope, and does not include any measurements supported only by expansion modules.  To add additional measurement types supported by your model, edit the driver using midedit.</Description>
            </Property>
            <Property>
               <Name>Source</Name>
               <Location>measurement</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>MEASU:&lt;ID&gt;:SOUrce</ConfigureCommand>
                     <QueryCommand>MEASU:&lt;ID&gt;:SOUrce?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="channel1" Value="CH1"/>
                     <Enum Name="channel2" Value="CH2"/>
                     <Enum Name="channel3" Value="CH3"/>
                     <Enum Name="channel4" Value="CH4"/>
                     <Enum Name="reference1" Value="REF1"/>
                     <Enum Name="reference2" Value="REF2"/>
                     <Enum Name="reference3" Value="REF3"/>
                     <Enum Name="reference4" Value="REF4"/>
                     <Enum Name="math1" Value="MATH1"/>
                     <Enum Name="math2" Value="MATH2"/>
                     <Enum Name="math3" Value="MATH2"/>
                     <Enum Name="math4" Value="MATH4"/>
                     <Enum Name="histogram" Value="HISTOGRAM"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>channel1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the source of the measurement.</Description>
            </Property>
            <Property>
               <Name>Source2</Name>
               <Location>measurement</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>MEASU:&lt;ID&gt;:SOUrce2</ConfigureCommand>
                     <QueryCommand>MEASU:&lt;ID&gt;:SOUrce2?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="channel1" Value="CH1"/>
                     <Enum Name="channel2" Value="CH2"/>
                     <Enum Name="channel3" Value="CH3"/>
                     <Enum Name="channel4" Value="CH4"/>
                     <Enum Name="reference1" Value="REF1"/>
                     <Enum Name="reference2" Value="REF2"/>
                     <Enum Name="reference3" Value="REF3"/>
                     <Enum Name="reference4" Value="REF4"/>
                     <Enum Name="math1" Value="MATH1"/>
                     <Enum Name="math2" Value="MATH2"/>
                     <Enum Name="math3" Value="MATH2"/>
                     <Enum Name="math4" Value="MATH4"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>channel1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the source of the measurement.</Description>
            </Property>
            <Property>
               <Name>Units</Name>
               <Location>measurement</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>MEASU:&lt;ID&gt;:UNIts?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="hertz" Value="HZ"/>
                     <Enum Name="volts" Value="VOLTS"/>
                     <Enum Name="seconds" Value="S"/>
                     <Enum Name="hits" Value="HITS"/>
                     <Enum Name="decibells" Value="DB"/>
                     <Enum Name="voltseconds" Value="VS"/>
                     <Enum Name="voltvolts" Value="VV"/>
                     <Enum Name="watts" Value="W"/>
                     <Enum Name="waveforms" Value="WFMS"/>
                     <Enum Name="unknown" Value="?"/>
                     <Enum Name="degrees" Value="&#34;\b0&#34;"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>hertz</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the units for the oscilloscope measurement specified the mesurement type.</Description>
            </Property>
            <Property>
               <Name>Value</Name>
               <Location>measurement</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>MEASU:&lt;ID&gt;:VALue?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Returns the value of a measurement.  If the object is the immediate measurement object (the HwName property is 'IMMED') this property is always valid.  For the standard periodic measurements, it is only a valid valid if the MesesurementType is not 'none'.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo/>
      </Group>
      <Group>
         <Name>system</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="System1" Index="1"/>
         </Mappings>
         <PropertyInfo/>
         <MethodInfo>
            <Method>
               <Name>disablelocalcontrols</Name>
               <Location>system</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <Line Command="LOCK ALL" Output="false"/>
                  </Commands>
               </Code>
               <Description>DISABLELOCALCONTROLS Disable all front-panel buttons and knobs.

INVOKE(OBJ, 'disablelocalcontrols') 'unlocks' all front-panel keys and knobs.</Description>
            </Method>
            <Method>
               <Name>enablelocalcontrols</Name>
               <Location>system</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <Line Command="LOCK NONe" Output="false"/>
                  </Commands>
               </Code>
               <Description>ENABLELOCALCONTROLS Enable all front-panel buttons and knobs.

INVOKE(OBJ, 'enablelocalcontrols') 'locks' all front-panel keys and knobs.</Description>
            </Method>
            <Method>
               <Name>loadstate</Name>
               <Location>system</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function loadstate(obj,location)
% OBJ is the group object.
% LOCATION is the specified storage location

% Get the interface
interface = get(get(obj,'parent'),'interface');

% Error checking
    % LOCATION must be a scalar and between 1 and 10, inclusive.
    if ~isnumeric(location) 
        error('LOCATION must be numeric');
    elseif location ~= floor(location)
        error('LOCATION must be a scalar');
    elseif  location &gt;10 || location &lt;1
            error('LOCATION must be between 1 and 10 inclusive');
    end
    
% Send memory name query command
fprintf(interface,['*RCL ' num2str(location)])
</MCode>
               </Code>
               <Description>LOADSTATE  Recall a previously stored state.

INVOKE(OBJ, loadstate, location) restores the state of the oscilloscope from a copy of settings stores in memory.</Description>
            </Method>
            <Method>
               <Name>savestate</Name>
               <Location>system</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function savestate(obj,location)
% OBJ is the group object.
% LOCATION is the specified storage location

% Get the interface
interface = get(get(obj,'parent'),'interface');

% Error checking
    % LOCATION must be a scalar and between 1 and 10, inclusive.
    if ~isnumeric(location) 
        error('LOCATION must be numeric');
    elseif location ~= floor(location)
        error('LOCATION must be a scalar');
    elseif  location &gt;10 || location &lt;1
            error('LOCATION must be between 1 and 10 inclusive');
    end
    
% Send memory name query command
fprintf(interface,['*SAV ' num2str(location)])
</MCode>
               </Code>
               <Description>SAVESTATE  Save the current state of the oscilloscope.

INVOKE(OBJ,'savestate',location) stores an instrument configuration at the specified memory location, LOCATION.
</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>trigger</Name>
         <Description>Properties and methods for controlling the A Trigger</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="trigger1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>HoldoffTime</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>TRIGger:A:HOLDoff:TIMe</ConfigureCommand>
                     <QueryCommand>TRIGger:A:HOLDoff:TIMe?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="12.0" Min="2.5E-7"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>2.5E-7</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>sets or queries the selected triggers's holdoff time</Description>
            </Property>
            <Property>
               <Name>HoldoffType</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:A:Holdoff:by</ConfigureCommand>
                     <QueryCommand>Trigger:A:Holdoff:by?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="time" Value="TIM"/>
                     <Enum Name="default" Value="DEFA"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>time</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the selected trigger's holdoff type</Description>
            </Property>
            <Property>
               <Name>Mode</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:A:Mode</ConfigureCommand>
                     <QueryCommand>Trigger:A:Mode?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="auto" Value="AUTO"/>
                     <Enum Name="normal" Value="NORM"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>normal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the trigger mode for the edge trigger type.</Description>
            </Property>
            <Property>
               <Name>Source</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>TRIGger:A:EDGE:SOURce</ConfigureCommand>
                     <QueryCommand>TRIGger:A:EDGE:SOURce?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="channel1" Value="CH1"/>
                     <Enum Name="channel2" Value="CH2"/>
                     <Enum Name="channel3" Value="CH3"/>
                     <Enum Name="channel4" Value="CH4"/>
                     <Enum Name="auxiliary" Value="AUX"/>
                     <Enum Name="acline" Value="LINE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>channel1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
            <Property>
               <Name>State</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>TRIGger:STATE?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="armed" Value="Armed"/>
                     <Enum Name="ready" Value="Ready"/>
                     <Enum Name="trigger" Value="Trigger"/>
                     <Enum Name="auto" Value="Auto"/>
                     <Enum Name="save" Value="Save"/>
                     <Enum Name="dpo" Value="DPO"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>Armed</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>Sets or query whether or not the B trigger is part of the triggering sequence</Description>
            </Property>
            <Property>
               <Name>TriggerType</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:A:Type</ConfigureCommand>
                     <QueryCommand>Trigger:A:Type?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="edge" Value="EDGE"/>
                     <Enum Name="logic" Value="LOGIC"/>
                     <Enum Name="pulse" Value="PULSE"/>
                     <Enum Name="comm" Value="COMM"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>edge</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the type of oscilloscope trigger.  This is equivalent to setting Type in the Trigger menu.</Description>
            </Property>
            <Property>
               <Name>VideoPolarity</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:A:Video:Polarity</ConfigureCommand>
                     <QueryCommand>Trigger:A:Video:Polarity?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="normal" Value="NORMAL"/>
                     <Enum Name="inverted" Value="INVERT"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>normal</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the video trigger polarity.  This is equivalent to selecting Polarity in the Trigger/Video menu.</Description>
            </Property>
            <Property>
               <Name>VideoSource</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:A:Video:Source</ConfigureCommand>
                     <QueryCommand>Trigger:A:Video:Source?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="channel1" Value="ch1"/>
                     <Enum Name="channel2" Value="ch2"/>
                     <Enum Name="channel3" Value="CH3"/>
                     <Enum Name="channel4" Value="CH4"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>channel1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the source for the main video trigger.  This is equivalent to selecting Source in the Video trigger menu.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>trigger</Name>
               <Location>trigger</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <Line Command="Trigger force" Output="false"/>
                  </Commands>
               </Code>
               <Description>TRIGGER Trigger the instrument.

INVOKE(OBJ,'TRIGGER') performs a Group Execute trigger.</Description>
            </Method>
         </MethodInfo>
      </Group>
      <Group>
         <Name>triggerb</Name>
         <Description>Properties and methods for controlling the B Trigger</Description>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="TriggerB1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>Coupling</Name>
               <Location>triggerb</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:B:Edge:Coupling</ConfigureCommand>
                     <QueryCommand>Trigger:B:Edge:Coupling?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="dc" Value="DC"/>
                     <Enum Name="noiseRejection" Value="NOISEREJ"/>
                     <Enum Name="atrigger" Value="ATRIGGER"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>dc</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the type of coupling for the B edge trigger.</Description>
            </Property>
            <Property>
               <Name>Level</Name>
               <Location>triggerb</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get Device Object
deviceObj = get(obj,'Parent');

%get Interface
interface = get(deviceObj,'Interface');

id = 'B';

%tell the device you want the value
fprintf(interface,['TRIGGer:',id,':LEVel?']);

%get the value
propertyValue = fscanf(interface,'%f');</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

%get Device Object
deviceObj = get(obj,'Parent');

%get Interface
interface = get(deviceObj,'Interface');

id = 'B';

%if is one of the enumerated strings, just pass it right on
if ischar(propertyValue)
	%set the value
	fprintf(interface,['TRIGGer:',id,':LEVel ',num2str(propertyValue)]);
else
	%get the source
	fprintf(interface,['TRIGGer:',id,':EDGE:SOURce?']);
	source = deblank(fscanf(interface));

	acceptableSources = {'ch1','ch2','ch3','ch4','auxiliary'};
	if isempty(strmatch(lower(source),acceptableSources))
		error(['Unexpected value for source. Expect ch1, ch2, ch3, ch4, or auxiliary. Recevied: ',...
			source]);
	end%if isempty(strmatch(lower(source),acceptableSource))

	%if source is auxiliary, don't check property value
	if isempty(strmatch(lower(source),{'ch1','ch2','ch3','ch4'}));
		fprintf(interface,['TRIGGer:',id,':LEVel ',num2str(propertyValue)]);
	else

		%get the scale
		fprintf(interface,[source,':SCAle?']);
		scale = fscanf(interface,'%f');

		%when source is zeroed, Trigger Level can go to plus or minus 8 times the scale or the source
		range = 16*scale;

		%get the source's position
		fprintf(interface,[source,':POSition?']);
		position = fscanf(interface,'%f');

		%position is in divs, we need it in volts, scale is volts/div
		position = position*scale;

		minimum = -1*range/2 - position;
		maximum = range/2 - position;

		if (propertyValue &gt; maximum)
			error(['Invalid value for Level. Valid values: a value from ',...
				num2str(minimum),' to ',num2str(maximum),' (inclusive).']);
		end%if propertyValue &gt; maximum
		if (propertyValue &lt; minimum)
			error(['Invalid value for Level. Valid values: a value from ',...
				num2str(minimum),' to ',num2str(maximum),' (inclusive).']);
		end%if propertyValue &lt; minimum

		%set the value
		fprintf(interface,['TRIGGer:',id,':LEVel ',num2str(propertyValue)]);
	
	end%if ~isempty(strmatch(lower(source),{'ext','ext5'}));
	
end%if ischar(propertyValue)</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <DependentProperty>Source</DependentProperty>
                  <DependentPropertyValue>ch1</DependentPropertyValue>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="12.0" Min="-12.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ecl" Value="ECL"/>
                     <Enum Name="ttl" Value="TTL"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>Double</Type>
                  <DependentProperty>Source</DependentProperty>
                  <DependentPropertyValue>ch2</DependentPropertyValue>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="12.0" Min="-12.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>Double</Type>
                  <DependentProperty>Source</DependentProperty>
                  <DependentPropertyValue>ch3</DependentPropertyValue>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="12.0" Min="-12.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>Double</Type>
                  <DependentProperty>Source</DependentProperty>
                  <DependentPropertyValue>ch4</DependentPropertyValue>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="12.0" Min="-12.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <PermissibleType>
                  <Type>Double</Type>
                  <DependentProperty>Source</DependentProperty>
                  <DependentPropertyValue>auxiliary</DependentPropertyValue>
                  <Constraint>bounded</Constraint>
                  <ConstraintValue>
                     <Range Max="8.0" Min="-8.0"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>0.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets the oscilloscope B trigger level.</Description>
            </Property>
            <Property>
               <Name>Slope</Name>
               <Location>triggerb</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:B:Edge:Slope</ConfigureCommand>
                     <QueryCommand>Trigger:B:Edge:Slope?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="falling" Value="FALL"/>
                     <Enum Name="rising" Value="RISE"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>rising</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Selects a rising or falling slope for the B edge trigger.  </Description>
            </Property>
            <Property>
               <Name>Source</Name>
               <Location>triggerb</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>Trigger:B:Edge:Source</ConfigureCommand>
                     <QueryCommand>Trigger:B:Edge:Source?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="channel1" Value="CH1"/>
                     <Enum Name="channel2" Value="CH2"/>
                     <Enum Name="channel3" Value="CH3"/>
                     <Enum Name="channel4" Value="CH4"/>
                     <Enum Name="auxiliary" Value="AUXILIARY"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>channel1</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets of the source for the B edge trigger.</Description>
            </Property>
         </PropertyInfo>
         <MethodInfo/>
      </Group>
      <Group>
         <Name>waveform</Name>
         <Description/>
         <Command/>
         <Size>1</Size>
         <Mappings>
            <ChannelMap Command="Waveform1" Index="1"/>
         </Mappings>
         <PropertyInfo>
            <Property>
               <Name>ByteOrder</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>WFMOutPre:BYT_Or</ConfigureCommand>
                     <QueryCommand>WFMOutpre:BYT_Or?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="bigEndian" Value="MSB"/>
                     <Enum Name="littleEndian" Value="LSB"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>littleEndian</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries which byte of binary waveform data is transmitted first during a waveform transfer.</Description>
            </Property>
            <Property>
               <Name>EndingPoint</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>DATa:STOP</ConfigureCommand>
                     <QueryCommand>DATa:STOP?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the ending point for waveformm data transfers.</Description>
            </Property>
            <Property>
               <Name>FirstPoint</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand>DATa:STARt</ConfigureCommand>
                     <QueryCommand>DATa:STARt?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>1.0</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description>Sets or queries the starting point for waveformm data transfers.</Description>
            </Property>
            <Property>
               <Name>MaxNumberPoint</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>InstrumentCommand</Type>
               <Code>
                  <Commands>
                     <ConfigureCommand/>
                     <QueryCommand>HORizontal:RECordlength?</QueryCommand>
                  </Commands>
               </Code>
               <PermissibleType>
                  <Type>Double</Type>
                  <Constraint>none</Constraint>
               </PermissibleType>
               <DefaultValue>0</DefaultValue>
               <ReadOnly>always</ReadOnly>
               <Description>The maximum number of acqusition data points.</Description>
            </Property>
            <Property>
               <Name>Precision</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <GetMCode>function propertyValue = getProperty(obj, propertyName)
% Return a property value.
%   This function is called to return the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

% Get interface
interface = get(get(obj,'parent'),'interface');
propertyValue = '';

% Set data width 
fprintf(interface,'WFMO:Byt_NR?')
width = fscanf(interface);

% Remove the newline character at the end of the string
% The same is done for encoding
width(length(width))= '';
width  = str2num(width);

% Check the data format and define propertyValue to the appropriate value
fprintf(interface,'DATA:ENCdg?')
encoding  = fscanf(interface);
encoding(length(encoding)) = '';

% define propertyValue with the right value
if any(strcmpi(encoding,{'RIBinary','SRIbinary'}))
    propertyValue = ['int' num2str(8*width)];
elseif any(strcmpi(encoding,{'RPBinary','SRPbinary'}))
     propertyValue = ['uint' num2str(8*width)];
else propertyValue = 'ascii';
end

</GetMCode>
                  <SetMCode>function set(obj, propertyName, propertyValue)
% Set a property value.
%   This function is called to set the device or group object property
%   value. If the property is a group property, OBJ is the group object. If
%   the property is a base device property, OBJ is the device object.

% Get interface
interface = get(get(obj,'parent'),'interface');

% Get the byte order
fprintf(interface,'WFMOutPre:BYT_Or?')

% Get the order and remove newline character in string
order = fscanf(interface);
order(length(order)) = '';

% Only an S differenciates the two commands(RIBinary and SRIBinary)
% for signed integers. The S will be added to the command if the byte 
% order is LSB
byteOrder ='';
if strcmpi(order,'LSB') == 1
    byteOrder = 'S';
end

% Specify format
if strcmpi(propertyValue,'ascii')
    fprintf(interface,['DATA:ENCdg ASCIi'])
    %setting data:enc to ASCII reset Byte_Or to MSB, which is unneccssary.
    %this sets it back to what is was previously.
    fprintf(interface,['WFMOutPre:BYT_Or ',order]);
elseif any(strcmpi(propertyValue,{'int8','int16'}))
    fprintf(interface,['DATA:ENCdg ' byteOrder 'RIBinary'])
elseif any(strcmpi(propertyValue,{'uint8','uint16','uint32','unit64'}))
  fprintf(interface,['DATA:ENCdg ' byteOrder 'RPBinary'])
end

% Set the width
if any(strcmpi(propertyValue,{'int8','uint8'}))
    fprintf(interface,['WFMO:Byt_NR 1'])
elseif any(strcmpi(propertyValue,{'int16','uint16'}))
    fprintf(interface,['WFMO:Byt_NR 2'])
elseif any(strcmpi(propertyValue,{'int32','uint32'}))
    fprintf(interface,['WFMO:Byt_NR 4'])
elseif any(strcmpi(propertyValue,{'int64','uint64'}))
    fprintf(interface,['WFMO:Byt_NR 8'])
else
    fprintf(interface,['WFMO:Byt_NR 1']);
   % error('Invalid format. Valid values are: int8,int16, uint8,uint16.')
end
    

</SetMCode>
               </Code>
               <PermissibleType>
                  <Type>String</Type>
                  <Constraint>enum</Constraint>
                  <ConstraintValue>
                     <Enum Name="ascii" Value="ASCIi"/>
                     <Enum Name="int8" Value="int8"/>
                     <Enum Name="int16" Value="int16"/>
                     <Enum Name="uint8" Value="uint8"/>
                     <Enum Name="uint16" Value="uint16"/>
                     <Enum Name="int32" Value="int32"/>
                     <Enum Name="int64" Value="int64"/>
                     <Enum Name="uint32" Value="uint32"/>
                     <Enum Name="uint64" Value="uint64"/>
                  </ConstraintValue>
               </PermissibleType>
               <DefaultValue>ascii</DefaultValue>
               <ReadOnly>never</ReadOnly>
               <Description/>
            </Property>
         </PropertyInfo>
         <MethodInfo>
            <Method>
               <Name>readwaveform</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function [y, x, yunit, xunit] = readwaveform(obj, source, varargin)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

num1 = 1;
num2 = 4;
snum1 = num2str(num1);
snum2 = num2str(num2);

if (nargout == 0)
    return;
end

scale = true;
y = [];
x = [];
yunit = 'unknown';
xunit = 'unknown';

if strcmpi(source(1),'c')
	type = 'ch';	
elseif strcmpi(source(1),'r')
	type = 'ref';	
elseif strcmpi(source(1),'m')
	type = 'math';	
else
	error('Invalid SOURCE. SOURCE must be one of: channel&lt;x&gt;, reference&lt;x&gt;, or math&lt;x&gt;, where x is an integer from ',snum2,' to ',snum2);	
end

try
	pos = str2num(source(length(source)));
catch
	error('Invalid SOURCE. SOURCE must be one of: channel&lt;x&gt;, reference&lt;x&gt;, or math&lt;x&gt;, where x is an integer from ',snum2,' to ',snum2);	
end

if pos&lt;num1 || pos&gt;num2
	error('Invalid SOURCE. SOURCE must be one of: channel&lt;x&gt;, reference&lt;x&gt;, or math&lt;x&gt;, where x is an integer from ',snum2,' to ',snum2);	
end

trueSource = [type, num2str(pos)];

if (nargin &gt; 2)
    try
        scale = logical(varargin{1});
    catch
        error('SCALE must be a logical.');
    end
end

% Get interface
interface = get(get(obj,'parent'),'interface');

oldPrecision = get(obj, 'Precision');
oldByteOrder = get(obj, 'ByteOrder');

set(obj, 'Precision', 'int16');
set(obj, 'ByteOrder', 'littleEndian');

try 
    % Specify source
    fprintf(interface,['DATA:SOURCE ' trueSource]);

    % Issue the curve transfer command.
    fprintf(interface, 'CURVE?');

	raw = binblockread(interface, 'int16');

    % Tektronix scopes send and extra terminator after the binblock.
    fread(interface, 1);
catch
	%if there is a problem with binblockread, you will not be able to reset
	% Precision or ByteOrder
    error(lasterr);
end

if (isempty(raw))
    set(obj, 'Precision', oldPrecision);
    set(obj, 'ByteOrder', oldByteOrder);
    error('An error occurred while reading the waveform.');
end

if (scale == false)
    y = raw;
    if (nargout &lt; 2)
        set(obj, 'Precision', oldPrecision);
        set(obj, 'ByteOrder', oldByteOrder);
        return;
    end
    ptcnt = str2num(query(interface, 'WFMoutPRE:NR_PT?'));
    x = 1:ptcnt;
    
    if (nargout &gt; 2)
        xunit = query(interface, 'WFMoutPRE:XUnit?');
        xunit(xunit == '"') = [];
        yunit = query(interface, 'WFMoutPRE:YUnit?');
        yunit(yunit == '"') = [];
    end
else
    yoffs = str2num(query(interface, 'WFMoutPRE:YOFF?'));
    ymult = str2num(query(interface, 'WFMoutPRE:YMULT?'));
    yzero = str2num(query(interface, 'WFMoutPRE:YZERO?'));
    y = ((raw - yoffs) .* ymult) + yzero;
    if (nargout &lt; 2)
        set(obj, 'Precision', oldPrecision);
        set(obj, 'ByteOrder', oldByteOrder);
        return;
    end
    xzero = str2num(query(interface, 'WFMoutPRE:XZERO?'));
    xincr = str2num(query(interface, 'WFMoutPRE:XINCR?'));
    ptcnt = str2num(query(interface, 'WFMoutPRE:NR_PT?'));
    x = (((0:(ptcnt-1)) .* xincr) + xzero);
    
    if (nargout &gt; 2)
        xunit = query(interface, 'WFMoutPRE:XUnit?');
        xunit(xunit == '"') = [];
        yunit = query(interface, 'WFMoutPRE:YUnit?');
        yunit(yunit == '"') = [];
    end
end
y = y';

set(obj, 'Precision', oldPrecision);
set(obj, 'ByteOrder', oldByteOrder);
</MCode>
               </Code>
               <Description>READWAVEFORM Transfer waveforms from the oscilloscope to MATLAB.

[Y, T] = INVOKE(obj, 'readwaveform', CHANNEL) returns a waveform from the instrument,
using channel string, CHANNEL.  Valid channel values are channel&lt;x&gt;, reference&lt;y&gt;, and
math, where &lt;x&gt; is a number between 1 and the number of channels on the instrument and &lt;y&gt; is a letter between A and the number of reference channels on the instrument.

[Y, T] = INVOKE(obj, 'readwaveform', CHANNEL, SCALE) returns the data scaled to real units if SCALE is true, or as raw data if SCALE is false.

To read the waveform data points the interface object associated with the device
object must have a sufficiently large InputBufferSize property value.  If you receive
an error about the buffer size being to small, or have difficulty reading a waveform,
verify that it is large enough.  The size must be greater than two times the number
of points in the waveform, plus approximately 50 bytes for header information.

Example:
	[y, t] = invoke(obj, 'readwaveform', 'channel1');
	[y, t] = invoke(obj, 'readwaveform', 'referenceA', false);

Example changing the buffer size:
	% Note the device object must be closed.
	interfaceObj = get(deviceObj, 'interface');
	% Allow for a 10,000 point waveform with a little extra room.
	set(interfaceObj, 'InputBufferSize', 21000);
	connect(deviceObj);
	[y, t] = invoke(obj, 'readwaveform', 'channel1');




</Description>
            </Method>
            <Method>
               <Name>storewaveform</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function storewaveform(obj, channel, location)
% If this is a group function, OBJ is the group object. If
% it a base device function, OBJ is the device object.

num1 = 1;
num2 = 4;
snum1 = num2str(num1);
snum2 = num2str(num2);

if strncmpi(channel,'channel',length('channel'))
	try
		pos = str2num(channel(length(channel)));
	catch
		error(['Invalid CHANNEL. CHANNEL must be channel&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
	end	
	if pos&lt;num1 || pos&gt;num2
		error(['Invalid CHANNEL. CHANNEL must be channel&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
	end	
	source = ['ch',num2str(pos)];	
else
	error(['Invalid CHANNEL. CHANNEL must be channel&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
end

if strncmpi(location,'reference',length('reference'))
	try
		pos = str2num(location(length(location)));
	catch
		error(['Invalid LOCATION. LOCATION must be reference&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
	end	
	if pos&lt;num1 || pos&gt;num2
		error(['Invalid LOCATION. LOCATION must be reference&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
	end	
	dest = ['ref',num2str(pos)];	
else
	error(['Invalid LOCATION. LOCATION must be reference&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
end


% Get interface
interface = get(get(obj,'parent'),'interface');

fprintf(interface, ['SAVe:WAVEform ' source ',MAIn,' dest]);</MCode>
               </Code>
               <Description>STOREWAVEFORM Save a waveform to oscilloscope memory.

INVOKE(OBJ, 'storewaveform', CHANNEL, LOCATION) saves the waveform from CHANNEL to memory location, LOCATION.
</Description>
            </Method>
            <Method>
               <Name>writewaveform</Name>
               <Location>waveform</Location>
               <CapabilityGroup>Base</CapabilityGroup>
               <Type>MCode</Type>
               <Code>
                  <MCode>function writewaveform(obj, datapoints, destination)

num1 = 1;
num2 = 4;
snum1 = num2str(num1);
snum2 = num2str(num2);

% Validate destination
if strncmpi(destination,'reference',length('reference'))
	try
		pos = str2num(destination(length(destination)));
	catch
		error(['Invalid LOCATION. LOCATION must be reference&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
	end	
	if pos&lt;num1 || pos&gt;num2
		error(['Invalid LOCATION. LOCATION must be reference&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
	end	
	dest = ['ref',num2str(pos)];	
else
	error(['Invalid LOCATION. LOCATION must be reference&lt;x&gt;, where x is an integer from ',snum1,' to ',snum2]);
end

% Check that the array contains only numeric data
if ~isnumeric(datapoints) || length(size(datapoints)) &gt; 2 || min(size(datapoints)) &gt; 1
    error('DATA must be a 1 x n numeric array');
end

    
oldPrecision = get(obj, 'Precision');
oldByteOrder = get(obj, 'ByteOrder');

set(obj, 'Precision', 'int16');
set(obj, 'ByteOrder', 'littleEndian');

%Get interface
interface = get(get(obj,'parent'),'interface');

try
    fprintf(inteface,['DATA:DESTination ', dest]);
    fprintf(interface,['CURVe ' datapoints]);
    binblockwrite(interface, datapoints, 'int16');
catch
end

set(obj, 'Precision', oldPrecision);
set(obj, 'ByteOrder', oldByteOrder);

</MCode>
               </Code>
               <Description>writeWAVEFORM Transfer waveforms in the oscilloscope.

INVOKE(OBJ, 'writewaveform', POINTS) downloads the numeric data POINTS to the oscilloscope. 

Warning: This operation can be very slow on TDS-200 series oscillscopes.
</Description>
            </Method>
         </MethodInfo>
      </Group>
   </GroupInfo>
</MATLABInstrumentDriver>