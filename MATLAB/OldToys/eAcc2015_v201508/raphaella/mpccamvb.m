function [methodinfo,structs,enuminfo,ThunkLibName]=mpccamvb
%MPCCAMVB Create structures to define interfaces found in 'Pccamvb'.

%This function was generated by loadlibrary.m parser version 1.1.6.24 on Tue Oct  5 18:29:50 2010
%perl options:'Pccamvb.i -outfile=mpccamvb.m'
ival={cell(1,0)}; % change 0 to the actual number of functions to preallocate the data.
structs=[];enuminfo=[];fcnNum=1;
fcns=struct('name',ival,'calltype',ival,'LHS',ival,'RHS',ival,'alias',ival);
ThunkLibName=[];
% int WINAPI INITBOARD ( int board , void ** hdriver ); 
fcns.name{fcnNum}='INITBOARD'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'voidPtrPtr'};fcnNum=fcnNum+1;
% int WINAPI INITBOARDP ( int board , void ** hdriver ); 
fcns.name{fcnNum}='INITBOARDP'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'int32', 'voidPtrPtr'};fcnNum=fcnNum+1;
% int WINAPI CLOSEBOARD ( void ** hdriver ); 
fcns.name{fcnNum}='CLOSEBOARD'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtrPtr'};fcnNum=fcnNum+1;
% int WINAPI RESETBOARD ( HANDLE hdriver ); 
fcns.name{fcnNum}='RESETBOARD'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error'};fcnNum=fcnNum+1;
% int WINAPI GETBOARDPAR ( HANDLE hdriver , void * buf , int len ); 
fcns.name{fcnNum}='GETBOARDPAR'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'voidPtr', 'int32'};fcnNum=fcnNum+1;
% int WINAPI GETBOARDVAL ( HANDLE hdriver , int pcc_val , void * data ); 
fcns.name{fcnNum}='GETBOARDVAL'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int WINAPI SETMODE ( HANDLE hdriver , int mode , int explevel , int exptime , int hbin , int vbin , int gain , int offset , int bit_pix , int shift ); 
fcns.name{fcnNum}='SETMODE'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
% int WINAPI GETMODE ( HANDLE hdriver , int * mode , int * explevel , int * exptime , int * hbin , int * vbin , int * gain , int * offset , int * bit_pix , int * shift ); 
fcns.name{fcnNum}='GETMODE'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI WRRDORION ( HANDLE hdriver , int cmnd , int * data ); 
fcns.name{fcnNum}='WRRDORION'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI SET_EXPOSURE ( HANDLE hdriver , int time ); 
fcns.name{fcnNum}='SET_EXPOSURE'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32'};fcnNum=fcnNum+1;
% int WINAPI TRIGGER_CAMERA ( HANDLE hdriver ); 
fcns.name{fcnNum}='TRIGGER_CAMERA'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error'};fcnNum=fcnNum+1;
% int WINAPI START_CAMERA ( HANDLE hdriver ); 
fcns.name{fcnNum}='START_CAMERA'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error'};fcnNum=fcnNum+1;
% int WINAPI STOP_CAMERA ( HANDLE hdriver ); 
fcns.name{fcnNum}='STOP_CAMERA'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error'};fcnNum=fcnNum+1;
% int WINAPI GETSIZES ( HANDLE hdriver , int * ccdxsize , int * ccdysize , int * actualxsize , int * actualysize , int * bit_pix ); 
fcns.name{fcnNum}='GETSIZES'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI READTEMPERATURE ( HANDLE hdriver , int * ccd ); 
fcns.name{fcnNum}='READTEMPERATURE'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI READVERSION ( HANDLE hdriver , int typ , char * vers , int len ); 
fcns.name{fcnNum}='READVERSION'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'cstring', 'int32'};fcnNum=fcnNum+1;
% int WINAPI GETBUFFER_STATUS ( HANDLE hdriver , int bufnr , int mode , int * stat , int len ); 
fcns.name{fcnNum}='GETBUFFER_STATUS'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'int32Ptr', 'int32'};fcnNum=fcnNum+1;
% int WINAPI GETBUFFERVAL ( HANDLE hdriver , int bufnr , int pcc_bufval , void * data ); 
fcns.name{fcnNum}='GETBUFFERVAL'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'voidPtr'};fcnNum=fcnNum+1;
% int WINAPI ADD_BUFFER_TO_LIST ( HANDLE hdriver , int bufnr , int size , int offset , int data ); 
fcns.name{fcnNum}='ADD_BUFFER_TO_LIST'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'int32', 'int32'};fcnNum=fcnNum+1;
% int WINAPI ADD_PHYS_BUFFER_TO_LIST ( HANDLE hdriver , int bufnr , int size , int num_entry , unsigned int * table ); 
fcns.name{fcnNum}='ADD_PHYS_BUFFER_TO_LIST'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'int32', 'uint32Ptr'};fcnNum=fcnNum+1;
% int WINAPI REMOVE_BUFFER_FROM_LIST ( HANDLE hdriver , int bufnr ); 
fcns.name{fcnNum}='REMOVE_BUFFER_FROM_LIST'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32'};fcnNum=fcnNum+1;
% int WINAPI ALLOCATE_BUFFER ( HANDLE hdriver , int * bufnr , int * size ); 
fcns.name{fcnNum}='ALLOCATE_BUFFER'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32Ptr', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI FREE_BUFFER ( HANDLE hdriver , int bufnr ); 
fcns.name{fcnNum}='FREE_BUFFER'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32'};fcnNum=fcnNum+1;
% int WINAPI SETBUFFER_EVENT ( HANDLE hdriver , int bufnr , void ** hPicEvent ); 
fcns.name{fcnNum}='SETBUFFER_EVENT'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'voidPtrPtr'};fcnNum=fcnNum+1;
% int WINAPI MAP_BUFFER ( HANDLE hdriver , int bufnr , int size , int offset , DWORD * linadr ); 
fcns.name{fcnNum}='MAP_BUFFER'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'int32', 'uint32Ptr'};fcnNum=fcnNum+1;
% int WINAPI MAP_BUFFER_EX ( HANDLE hdriver , int bufnr , int size , int offset , void ** linadr ); 
fcns.name{fcnNum}='MAP_BUFFER_EX'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'int32', 'voidPtrPtr'};fcnNum=fcnNum+1;
% int WINAPI UNMAP_BUFFER ( HANDLE hdriver , int bufnr ); 
fcns.name{fcnNum}='UNMAP_BUFFER'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32'};fcnNum=fcnNum+1;
% int WINAPI SETORIONINT ( HANDLE hdriver , int bufnr , int mode , unsigned char * cmnd , int len ); 
fcns.name{fcnNum}='SETORIONINT'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'uint8Ptr', 'int32'};fcnNum=fcnNum+1;
% int WINAPI GETORIONINT ( HANDLE hdriver , int bufnr , int mode , unsigned char * data , int len ); 
fcns.name{fcnNum}='GETORIONINT'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'uint8Ptr', 'int32'};fcnNum=fcnNum+1;
% int WINAPI READEEPROM ( HANDLE hdriver , int mode , int adr , char * data ); 
fcns.name{fcnNum}='READEEPROM'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'cstring'};fcnNum=fcnNum+1;
% int WINAPI WRITEEEPROM ( HANDLE hdriver , int mode , int adr , char data ); 
fcns.name{fcnNum}='WRITEEEPROM'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'int32', 'int8'};fcnNum=fcnNum+1;
% int WINAPI SETTIMEOUTS ( HANDLE hdriver , DWORD dma , DWORD proc , DWORD head ); 
fcns.name{fcnNum}='SETTIMEOUTS'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'uint32', 'uint32', 'uint32'};fcnNum=fcnNum+1;
% int WINAPI SETDRIVER_EVENT ( HANDLE hdriver , int mode , void ** hHeadEvent ); 
fcns.name{fcnNum}='SETDRIVER_EVENT'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'voidPtrPtr'};fcnNum=fcnNum+1;
% int WINAPI READ_TEMP ( HANDLE hdriver , int * ccd_temp , int * ele_temp ); 
fcns.name{fcnNum}='READ_TEMP'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32Ptr', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI SET_NOMINAL_PELTIER_TEMP ( HANDLE hdriver , int temp ); 
fcns.name{fcnNum}='SET_NOMINAL_PELTIER_TEMP'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32'};fcnNum=fcnNum+1;
% int WINAPI GET_NOMINAL_PELTIER_TEMP ( HANDLE hdriver , int * temp ); 
fcns.name{fcnNum}='GET_NOMINAL_PELTIER_TEMP'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI SET_STANDBY_MODE ( HANDLE hdriver , int mode ); 
fcns.name{fcnNum}='SET_STANDBY_MODE'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32'};fcnNum=fcnNum+1;
% int WINAPI GET_STANDBY_MODE ( HANDLE hdriver , int * mode ); 
fcns.name{fcnNum}='GET_STANDBY_MODE'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32Ptr'};fcnNum=fcnNum+1;
% int WINAPI PCC_MEMCPY ( void * dest , void * source , int len ); 
fcns.name{fcnNum}='PCC_MEMCPY'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'voidPtr', 'voidPtr', 'int32'};fcnNum=fcnNum+1;
% int WINAPI PCC_GET_VERSION ( HANDLE hdriver , char * dll , char * sys ); 
fcns.name{fcnNum}='PCC_GET_VERSION'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'cstring', 'cstring'};fcnNum=fcnNum+1;
% int WINAPI PCC_WAITFORBUFFER ( HANDLE hdriver , int nr_of_buffer , PCC_Buflist * bl , int timeout ); 
fcns.name{fcnNum}='PCC_WAITFORBUFFER'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32', 'PCC_BuflistPtr', 'int32'};fcnNum=fcnNum+1;
% int WINAPI PCC_RESETEVENT ( HANDLE hdriver , int bufnr ); 
fcns.name{fcnNum}='PCC_RESETEVENT'; fcns.calltype{fcnNum}='stdcall'; fcns.LHS{fcnNum}='int32'; fcns.RHS{fcnNum}={'error', 'int32'};fcnNum=fcnNum+1;
structs.PCC_Buflist.members=struct('bufnr1', 'int32', 'BufferStatus1', 'uint32', 'counter1', 'uint32', 'hBufferEvent1', 'error', 'bufnr2', 'int32', 'BufferStatus2', 'uint32', 'counter2', 'uint32', 'hBufferEvent2', 'error', 'bufnr3', 'int32', 'BufferStatus3', 'uint32', 'counter3', 'uint32', 'hBufferEvent3', 'error', 'bufnr4', 'int32', 'BufferStatus4', 'uint32', 'counter4', 'uint32', 'hBufferEvent4', 'error');
methodinfo=fcns;